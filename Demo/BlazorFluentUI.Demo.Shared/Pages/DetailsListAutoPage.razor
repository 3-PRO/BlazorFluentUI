@page "/detailsListAutoPage"

@using DynamicData
@using DynamicData.Binding
@using System.Collections.ObjectModel
@using System.Reactive.Linq
@using System.Reactive.Subjects

<BFUStack Style="height:100%;">
    <h3>DetailsListAuto</h3>
    <BFUStack Horizontal="true" Tokens="new BFUStackTokens { ChildrenGap = new double[] { 10.0 } }">
        <BFUToggle Label="IsVirtualizing" OnText="true" OffText="false" @bind-Checked="isVirtualizing" />
        <BFUToggle Label="IsCompact" OnText="true" OffText="false" @bind-Checked="isCompact" />
        <BFUDropdown ItemsSource=@selectionModeOptions
                     @bind-SelectedOption=selectedModeOption
                     Style="max-width:300px;">
        </BFUDropdown>
    </BFUStack>
    <BFUTextField Label="Filter Description"
                  Value=@filter
                  OnInput=@(val => { filter = val; descriptionColumn.FilterPredicate = prop => prop.Contains(filter); }) />

    <BFUDetailsListAuto ItemsSource="dataSource"
                    IsVirtualizing="isVirtualizing"
                    Compact="isCompact"
                    Columns="columnsSource"
                    GetKey=@(x=>x.Key)
                    LayoutMode="DetailsListLayoutMode.Justified"
                    @bind-Selection="selection"
                    SelectionMode=@((SelectionMode)Enum.Parse(typeof(SelectionMode), selectedModeOption.Key))
                    @ref="detailsList" />
</BFUStack>

@code {

    // You DO NOT have to use DynamicData and Observables with DetailsList.  You can do it all manually.  See
    // https://developer.microsoft.com/en-us/fluentui#/controls/web/detailslist for examples of how to use DetailsList
    // other ways.

    bool isVirtualizing = false;
    bool isCompact = false;
    IBFUDropdownOption selectedModeOption;
    List<IBFUDropdownOption> selectionModeOptions;

    BFUDetailsListAuto<DataItem> detailsList;
    Selection<DataItem> selection = new Selection<DataItem>();

    // SourceCache is from DynamicData and is basically a container for your items that you can dynamically transform by filtering, sorting, etc.
    //SourceCache<DataItem, string> dataSource = new SourceCache<DataItem, string>(x => x.Key);
    List<DataItem> dataSource = new List<DataItem>();
    //public ReadOnlyObservableCollection<DataItem> ReadonlyList;
    int count = 0;

    // We're creating another container for the column array that needs to be defined to show columns in DetailsList.
    //SourceCache<BFUDetailsRowColumn<DataItem>, string> columnsSource = new SourceCache<BFUDetailsRowColumn<DataItem>, string>(x => x.Key);
    List<BFUDetailsRowColumn<DataItem>> columnsSource = new List<BFUDetailsRowColumn<DataItem>>();
    //public ReadOnlyObservableCollection<BFUDetailsRowColumn<DataItem>> ReadonlyColumns;

    string filter = "";
    BFUDetailsRowColumn<DataItem, string> descriptionColumn;

    protected override void OnInitialized()
    {
        selectionModeOptions = Enum.GetValues(typeof(SelectionMode)).Cast<SelectionMode>()
           .Select(x => new BFUDropdownOption { Key = x.ToString(), Text = x.ToString() })
           .Cast<IBFUDropdownOption>()
           .ToList();
        selectedModeOption = selectionModeOptions.FirstOrDefault(x => x.Key == "Single");



        // We load the column data into the columnsSource SourceCache.
        columnsSource.Add(new BFUDetailsRowColumn<DataItem, int>("Key", x => x.KeyNumber) { MaxWidth = 70, Index = 0, IsResizable = true });
        columnsSource.Add(new BFUDetailsRowColumn<DataItem, string>("Name", x => x.DisplayName) { Index = 1, MaxWidth = 150, IsResizable = true });
        descriptionColumn = new BFUDetailsRowColumn<DataItem, string>("Description", x => x.Description) { Index = 2 };
        columnsSource.Add(descriptionColumn);

        // We're loading our sample data into the dataSource SourceCache.
        for (var i = 0; i < 100; i++)
        {
            count++;
            dataSource.Add(new DataItem(count));
        }



        // This is the meat of DynamicData.  We connect to the data SourceCache, apply the Filter (which is dynamic),
        // apply the Sort expression (which is also dynamic), and Bind it to a readonly list property.  This is what we're
        // going to display in the DetailsList.  It will update automatically which any changes we make.  Since DynamicData is
        // based on ReactiveExtensions, we have to Subscribe to it to make it "do stuff".
        //dataSource.Connect()
        //        //.Filter(dataContainer.DynamicDescriptionFilter)
        //        //.Sort(dataContainer.DynamicSortExpression)
        //        .Bind(out ReadonlyList)
        //        .Subscribe();

        // Likewise, we connect to the column SourceCache.  This lets us make a change in one column and everything gets updated
        // automatically.  We also have a Do operator in there that calls a StateHasChanged whenever the contents are changed or if
        // the Sort expression changes.
        //columnsSource.Connect()
        //    .Sort(SortExpressionComparer<BFUDetailsRowColumn<DataItem>>.Ascending(x => x.Index))
        //    .Bind(out ReadonlyColumns)
        //    .Do(_ => StateHasChanged())  //when a column is clicked, that column's details will update... but other columns won't.  Need to call StateHasChanged to redraw all.
        //    .Subscribe();



        base.OnInitialized();
    }




}